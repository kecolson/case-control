final.cls.samp$ssu.num <- (final.cls.samp$x)*(samp.num) # Calculate total number of individuals to be sampled for each cluster
final.cls.samp <- merge(final.cls.samp,cluster,by="cluster") # Merge in cluster sizes and sampling probability
# Calculate probability of an individual being sampled for each cluster
final.cls.samp$ssu.sampprob <- (final.cls.samp$ssu.num) / (final.cls.samp$popsize)
# Sample individuals from each cluster
svypop$id <- as.numeric(rownames(svypop)) # generate individual IDs
ind.pool <- svypop[,c("id",paste0("cluster.bias.",exposure))] # pool of individuals yet to be sampled (with cluster)
ind.samp.all <- c() # vector of IDs of sampled individuals
for(cls in final.cls.samp[,1]){
size <- final.cls.samp[final.cls.samp$cluster==cls,"ssu.num"] # Identify # of individuals to be sampled from cluster
ind.samp <- sample(ind.pool[ind.pool[,2]==cls,1], size = size) # Sample individuals from cluster
ind.samp.all <- c(ind.samp.all,ind.samp) # Append newly sampled individuals to previously sampled individuals
}
# Obtain sample data
control.samp <- svypop[svypop$id %in% ind.samp.all,]
if (sum(final.cls.samp$ssu.num>final.cls.samp$popsize)==0){
sizecheck <- TRUE # Set indicator to end loop if each cluster has sufficient individuals for sample
print("Size all good!")
} else {
print ("Insufficient cluster population :(")
}
if ((sum(control.samp$A==1)/nrow(control.samp)) - (sum(svypop$A==1)/Nsvypop) > 0.02 ){
biascheck <- TRUE # Set indicator to end loop if sample has sufficient bias
print("Bias all good!")
} else {
print ("Insufficient bias :(")
}
}
(sum(control.samp$A==1)/nrow(control.samp)) - (sum(svypop$A==1)/Nsvypop) > 0.02
(sum(control.samp$A==1)/nrow(control.samp)) - (sum(svypop$A==1)/Nsvypop)
cluster <- aggregate(data.frame(popsize = svypop[[paste0("cluster.bias.",exposure)]]), list(cluster = svypop[[paste0("cluster.bias.",exposure)]]), length) # Calculate cluster population size to determine cluster sampling probability (proportional to cluster population size)
cluster$cls.sampprob <- cluster$popsize/Nsvypop # Calculate cluster sampling probability
# Initialize data
cluster.samp.all <- c() # vector if IDs of sampled clusters
cluster.pool <- cluster[,] # pool of clusters yet to be sampled (with size and relative sampling probabilities)
total.samp.size <- 0 # running individual sample size
cluster.samp.sizes <- c()
# Calculate number of individuals to sample from each cluster, based on survey size, aiming to sample ~66% of clusters (with replacement)
samp.num <- ceiling((svysizenum) / (nrow(cluster)/(1.5)))
# Set data check indicatorS
sizecheck <- FALSE
biascheck <- FALSE
while (sizecheck == FALSE | biascheck == FALSE){ # loop in place to repeat sampling if cluster sizes aren't sufficient for needed sample sizes or there is insufficient exposure bias
while (total.samp.size<svysizenum){
# Update cluster pool by excluding those already sampled
#cluster.pool <- (cluster.pool)[!((cluster.pool[,1]) %in% cluster.samp.all),]
# Sample single cluster with probability proportional to size
cluster.samp <- sample(cluster.pool[,1],size=1,prob=cluster.pool[,3])
# Append new sampled cluster to clusters already sampled
cluster.samp.all <- c(cluster.samp.all,cluster.samp)
# Append cluster sample sizes for calculation of total size of sample
cluster.samp.sizes <- c(cluster.samp.sizes,samp.num)
# Update total size of individual sample
total.samp.size <- sum(cluster.samp.sizes)
}
# Confirm there are sufficient individuals in each cluster to fulfill sample sizes
final.cls.samp <- data.frame(table(cluster.samp.all)) # Tabulate number of times each cluster was sampled
names(final.cls.samp) <- c("cluster","x")
final.cls.samp$ssu.num <- (final.cls.samp$x)*(samp.num) # Calculate total number of individuals to be sampled for each cluster
final.cls.samp <- merge(final.cls.samp,cluster,by="cluster") # Merge in cluster sizes and sampling probability
# Calculate probability of an individual being sampled for each cluster
final.cls.samp$ssu.sampprob <- (final.cls.samp$ssu.num) / (final.cls.samp$popsize)
# Sample individuals from each cluster
svypop$id <- as.numeric(rownames(svypop)) # generate individual IDs
ind.pool <- svypop[,c("id",paste0("cluster.bias.",exposure))] # pool of individuals yet to be sampled (with cluster)
ind.samp.all <- c() # vector of IDs of sampled individuals
for(cls in final.cls.samp[,1]){
size <- final.cls.samp[final.cls.samp$cluster==cls,"ssu.num"] # Identify # of individuals to be sampled from cluster
ind.samp <- sample(ind.pool[ind.pool[,2]==cls,1], size = size) # Sample individuals from cluster
ind.samp.all <- c(ind.samp.all,ind.samp) # Append newly sampled individuals to previously sampled individuals
}
# Obtain sample data
control.samp <- svypop[svypop$id %in% ind.samp.all,]
(sum(control.samp$A==1)/nrow(control.samp)) - (sum(svypop$A==1)/Nsvypop)
(sum(control.samp$A==1)/nrow(control.samp))
control.samp$A==1
(sum(control.samp$A==1)/nrow(control.samp)) - (sum(svypop$A==1)/Nsvypop)
(sum(control.samp$A==1)/nrow(control.samp)) - (sum(svypop$A==1)/Nsvypop)
cluster <- aggregate(data.frame(popsize = svypop[[paste0("cluster.bias.",exposure)]]), list(cluster = svypop[[paste0("cluster.bias.",exposure)]]), length) # Calculate cluster population size to determine cluster sampling probability (proportional to cluster population size)
cluster$cls.sampprob <- cluster$popsize/Nsvypop # Calculate cluster sampling probability
# Initialize data
cluster.samp.all <- c() # vector if IDs of sampled clusters
cluster.pool <- cluster[,] # pool of clusters yet to be sampled (with size and relative sampling probabilities)
total.samp.size <- 0 # running individual sample size
cluster.samp.sizes <- c()
# Calculate number of individuals to sample from each cluster, based on survey size, aiming to sample ~66% of clusters (with replacement)
samp.num <- ceiling((svysizenum) / (nrow(cluster)/(1.5)))
# Set data check indicatorS
sizecheck <- FALSE
biascheck <- FALSE
while (sizecheck == FALSE | biascheck == FALSE){ # loop in place to repeat sampling if cluster sizes aren't sufficient for needed sample sizes or there is insufficient exposure bias
while (total.samp.size<svysizenum){
# Update cluster pool by excluding those already sampled
#cluster.pool <- (cluster.pool)[!((cluster.pool[,1]) %in% cluster.samp.all),]
# Sample single cluster with probability proportional to size
cluster.samp <- sample(cluster.pool[,1],size=1,prob=cluster.pool[,3])
# Append new sampled cluster to clusters already sampled
cluster.samp.all <- c(cluster.samp.all,cluster.samp)
# Append cluster sample sizes for calculation of total size of sample
cluster.samp.sizes <- c(cluster.samp.sizes,samp.num)
# Update total size of individual sample
total.samp.size <- sum(cluster.samp.sizes)
}
# Confirm there are sufficient individuals in each cluster to fulfill sample sizes
final.cls.samp <- data.frame(table(cluster.samp.all)) # Tabulate number of times each cluster was sampled
names(final.cls.samp) <- c("cluster","x")
final.cls.samp$ssu.num <- (final.cls.samp$x)*(samp.num) # Calculate total number of individuals to be sampled for each cluster
final.cls.samp <- merge(final.cls.samp,cluster,by="cluster") # Merge in cluster sizes and sampling probability
# Calculate probability of an individual being sampled for each cluster
final.cls.samp$ssu.sampprob <- (final.cls.samp$ssu.num) / (final.cls.samp$popsize)
# Sample individuals from each cluster
svypop$id <- as.numeric(rownames(svypop)) # generate individual IDs
ind.pool <- svypop[,c("id",paste0("cluster.bias.",exposure))] # pool of individuals yet to be sampled (with cluster)
ind.samp.all <- c() # vector of IDs of sampled individuals
for(cls in final.cls.samp[,1]){
size <- final.cls.samp[final.cls.samp$cluster==cls,"ssu.num"] # Identify # of individuals to be sampled from cluster
ind.samp <- sample(ind.pool[ind.pool[,2]==cls,1], size = size) # Sample individuals from cluster
ind.samp.all <- c(ind.samp.all,ind.samp) # Append newly sampled individuals to previously sampled individuals
}
# Obtain sample data
control.samp <- svypop[svypop$id %in% ind.samp.all,]
(sum(control.samp$A==1)/nrow(control.samp)) - (sum(svypop$A==1)/Nsvypop)
cluster <- aggregate(data.frame(popsize = svypop[[paste0("cluster.bias.",exposure)]]), list(cluster = svypop[[paste0("cluster.bias.",exposure)]]), length) # Calculate cluster population size to determine cluster sampling probability (proportional to cluster population size)
cluster$cls.sampprob <- cluster$popsize/Nsvypop # Calculate cluster sampling probability
# Initialize data
cluster.samp.all <- c() # vector if IDs of sampled clusters
cluster.pool <- cluster[,] # pool of clusters yet to be sampled (with size and relative sampling probabilities)
total.samp.size <- 0 # running individual sample size
cluster.samp.sizes <- c()
# Calculate number of individuals to sample from each cluster, based on survey size, aiming to sample ~66% of clusters (with replacement)
samp.num <- ceiling((svysizenum) / (nrow(cluster)/(1.5)))
# Set data check indicatorS
sizecheck <- FALSE
biascheck <- FALSE
while (total.samp.size<svysizenum){
# Update cluster pool by excluding those already sampled
#cluster.pool <- (cluster.pool)[!((cluster.pool[,1]) %in% cluster.samp.all),]
# Sample single cluster with probability proportional to size
cluster.samp <- sample(cluster.pool[,1],size=1,prob=cluster.pool[,3])
# Append new sampled cluster to clusters already sampled
cluster.samp.all <- c(cluster.samp.all,cluster.samp)
# Append cluster sample sizes for calculation of total size of sample
cluster.samp.sizes <- c(cluster.samp.sizes,samp.num)
# Update total size of individual sample
total.samp.size <- sum(cluster.samp.sizes)
}
# Confirm there are sufficient individuals in each cluster to fulfill sample sizes
final.cls.samp <- data.frame(table(cluster.samp.all)) # Tabulate number of times each cluster was sampled
names(final.cls.samp) <- c("cluster","x")
final.cls.samp$ssu.num <- (final.cls.samp$x)*(samp.num) # Calculate total number of individuals to be sampled for each cluster
final.cls.samp <- merge(final.cls.samp,cluster,by="cluster") # Merge in cluster sizes and sampling probability
# Calculate probability of an individual being sampled for each cluster
final.cls.samp$ssu.sampprob <- (final.cls.samp$ssu.num) / (final.cls.samp$popsize)
# Sample individuals from each cluster
svypop$id <- as.numeric(rownames(svypop)) # generate individual IDs
ind.pool <- svypop[,c("id",paste0("cluster.bias.",exposure))] # pool of individuals yet to be sampled (with cluster)
ind.samp.all <- c() # vector of IDs of sampled individuals
for(cls in final.cls.samp[,1]){
size <- final.cls.samp[final.cls.samp$cluster==cls,"ssu.num"] # Identify # of individuals to be sampled from cluster
ind.samp <- sample(ind.pool[ind.pool[,2]==cls,1], size = size) # Sample individuals from cluster
ind.samp.all <- c(ind.samp.all,ind.samp) # Append newly sampled individuals to previously sampled individuals
}
# Obtain sample data
control.samp <- svypop[svypop$id %in% ind.samp.all,]
(sum(control.samp$A==1)/nrow(control.samp)) - (sum(svypop$A==1)/Nsvypop)
cluster <- aggregate(data.frame(popsize = svypop[[paste0("cluster.bias.",exposure)]]), list(cluster = svypop[[paste0("cluster.bias.",exposure)]]), length) # Calculate cluster population size to determine cluster sampling probability (proportional to cluster population size)
cluster
cluster$cls.sampprob <- cluster$popsize/Nsvypop # Calculate cluster sampling probability
plot(cluster$cls.sampprob)
cluster.samp.all <- c() # vector if IDs of sampled clusters
cluster.pool <- cluster[,] # pool of clusters yet to be sampled (with size and relative sampling probabilities)
cluster.pool
total.samp.size <- 0 # running individual sample size
cluster.samp.sizes <- c()
ceiling((svysizenum) / (nrow(cluster)/(1.5)))
samp.num <- ceiling((svysizenum) / (nrow(cluster)/(1.5)))
cluster.pool[,3]
cluster.samp <- sample(cluster.pool[,1],size=1,prob=cluster.pool[,3])
cluster.samp
cluster.samp.all <- c(cluster.samp.all,cluster.samp)
cluster.samp.sizes <- c(cluster.samp.sizes,samp.num)
cluster.samp.sizes
total.samp.size <- sum(cluster.samp.sizes)
total.samp.size
while (total.samp.size<svysizenum){
# Update cluster pool by excluding those already sampled
#cluster.pool <- (cluster.pool)[!((cluster.pool[,1]) %in% cluster.samp.all),]
# Sample single cluster with probability proportional to size
cluster.samp <- sample(cluster.pool[,1],size=1,prob=cluster.pool[,3])
# Append new sampled cluster to clusters already sampled
cluster.samp.all <- c(cluster.samp.all,cluster.samp)
# Append cluster sample sizes for calculation of total size of sample
cluster.samp.sizes <- c(cluster.samp.sizes,samp.num)
# Update total size of individual sample
total.samp.size <- sum(cluster.samp.sizes)
}
total.samp.size
final.cls.samp <- data.frame(table(cluster.samp.all)) # Tabulate number of times each cluster was sampled
final.cls.samp
hist(cluster.samp.all)
names(final.cls.samp) <- c("cluster","x")
final.cls.samp$ssu.num <- (final.cls.samp$x)*(samp.num) # Calculate total number of individuals to be sampled for each cluster
final.cls.samp <- merge(final.cls.samp,cluster,by="cluster") # Merge in cluster sizes and sampling probability
final.cls.samp
final.cls.samp$ssu.sampprob <- (final.cls.samp$ssu.num) / (final.cls.samp$popsize)
svypop$id <- as.numeric(rownames(svypop)) # generate individual IDs
ind.pool <- svypop[,c("id",paste0("cluster.bias.",exposure))] # pool of individuals yet to be sampled (with cluster)
ind.pool
ind.samp.all <- c() # vector of IDs of sampled individuals
for(cls in final.cls.samp[,1]){
size <- final.cls.samp[final.cls.samp$cluster==cls,"ssu.num"] # Identify # of individuals to be sampled from cluster
ind.samp <- sample(ind.pool[ind.pool[,2]==cls,1], size = size) # Sample individuals from cluster
ind.samp.all <- c(ind.samp.all,ind.samp) # Append newly sampled individuals to previously sampled individuals
}
control.samp <- svypop[svypop$id %in% ind.samp.all,]
table(control.samp$cluster.bias.A.50)
final.cluster.samp
final.cls.samp
cluster.size.all <- c()
num.exposed.all <- c()
for(i in 1:100){
cluster.size.all <- (cluster.size.all,100*i)
num.exposed.all <- c(num.exposed.all,(i/100)*cluster.size)
}
cluster.size.all <- c()
num.exposed.all <- c()
for(i in 1:100){
cluster.size.all <- c(cluster.size.all,100*i)
num.exposed.all <- c(num.exposed.all,(i/100)*cluster.size)
}
cluster.size.all <- c()
num.exposed.all <- c()
for(i in 1:100){
cluster.size.all <- c(cluster.size.all,100*i)
num.exposed.all <- c(num.exposed.all,(i/100)*cluster.size.all[i])
}
cluster.size.all
num.exposed.all
num.unexposed.all <- cluster.size.all - num.exposed.all
num.unexposed.all
rep(NA,cluster.size.all)
id = 1
cluster <- rep(id,cluster.size.all[id])
cluster
A <- c(rep(1,num.exposed.all[id]),rep(0,num.unexposed.all[id]))
A
for(id in 1:100){
cluster <- rep(id,cluster.size.all[id])
A <- c(rep(1,num.exposed.all[id]),rep(0,num.unexposed.all[id]))
one.cluster <- cbind(cluster,A)
all.clusters <- rbind(all.clusters,one.cluster)
}
allclusters <- c()
for(id in 1:100){
cluster <- rep(id,cluster.size.all[id])
A <- c(rep(1,num.exposed.all[id]),rep(0,num.unexposed.all[id]))
one.cluster <- cbind(cluster,A)
all.clusters <- rbind(all.clusters,one.cluster)
}
all.clusters <- c()
for(id in 1:100){
cluster <- rep(id,cluster.size.all[id])
A <- c(rep(1,num.exposed.all[id]),rep(0,num.unexposed.all[id]))
one.cluster <- cbind(cluster,A)
all.clusters <- rbind(all.clusters,one.cluster)
}
all.clusters <- matrix(nrow=0,ncol=2)
all.clusters
all.clusters <- matrix(nrow=0,ncol=2)
for(id in 1:100){
cluster <- rep(id,cluster.size.all[id])
A <- c(rep(1,num.exposed.all[id]),rep(0,num.unexposed.all[id]))
one.cluster <- cbind(cluster,A)
all.clusters <- rbind(all.clusters,one.cluster)
}
all.clusters
all.clusters <- matrix(nrow=0,ncol=2)
id = 1
cluster <- rep(id,cluster.size.all[id])
cluster
A <- c(rep(1,num.exposed.all[id]),rep(0,num.unexposed.all[id]))
one.cluster
one.cluster <- cbind(cluster,A)
one.cluster
all.clusters <- rbind(all.clusters,one.cluster)
all.clusters
id = 2
cluster <- rep(id,cluster.size.all[id])
A <- c(rep(1,num.exposed.all[id]),rep(0,num.unexposed.all[id]))
one.cluster <- cbind(cluster,A)
all.clusters <- rbind(all.clusters,one.cluster)
all.clusters
cluster.size.all[id]
# Generate clusters in which larger clusters have more exposed individuals
cluster.size.all <- c()
num.exposed.all <- c()
for(i in 1:100){
cluster.size.all <- c(cluster.size.all,100*i)
num.exposed.all <- c(num.exposed.all,(i/100)*cluster.size.all[i])
}
num.unexposed.all <- cluster.size.all - num.exposed.all
# Construct sample
all.clusters <- matrix(nrow=0,ncol=2)
for(id in 1:100){
cluster <- rep(id,cluster.size.all[id])
A <- c(rep(1,num.exposed.all[id]),rep(0,num.unexposed.all[id]))
one.cluster <- cbind(cluster,A)
all.clusters <- rbind(all.clusters,one.cluster)
}
cluster.size.all
num.exposed.all
num.unexposed.all
cluster.size.all <- c()
num.exposed.all <- c()
for(i in 1:99){
cluster.size.all <- c(cluster.size.all,100*i)
num.exposed.all <- c(num.exposed.all,(i/100)*cluster.size.all[i])
}
num.unexposed.all <- cluster.size.all - num.exposed.all
# Construct sample
all.clusters <- matrix(nrow=0,ncol=2)
for(id in 1:100){
cluster <- rep(id,cluster.size.all[id])
A <- c(rep(1,num.exposed.all[id]),rep(0,num.unexposed.all[id]))
one.cluster <- cbind(cluster,A)
all.clusters <- rbind(all.clusters,one.cluster)
}
# Generate clusters in which larger clusters have more exposed individuals
cluster.size.all <- c()
num.exposed.all <- c()
for(i in 1:99){
cluster.size.all <- c(cluster.size.all,100*i)
num.exposed.all <- c(num.exposed.all,(i/100)*cluster.size.all[i])
}
num.unexposed.all <- cluster.size.all - num.exposed.all
# Construct sample
all.clusters <- matrix(nrow=0,ncol=2)
for(id in 1:99){
cluster <- rep(id,cluster.size.all[id])
A <- c(rep(1,num.exposed.all[id]),rep(0,num.unexposed.all[id]))
one.cluster <- cbind(cluster,A)
all.clusters <- rbind(all.clusters,one.cluster)
}
table(allclusters[,1])
all.clusters
# Generate clusters in which larger clusters have more exposed individuals
cluster.size.all <- c()
num.exposed.all <- c()
for(i in 1:99){
cluster.size.all <- c(cluster.size.all,100*i)
num.exposed.all <- c(num.exposed.all,(i/100)*cluster.size.all[i])
}
num.unexposed.all <- cluster.size.all - num.exposed.all
# Construct sample
all.clusters <- data.frame(cluster = integer(), A = integer())
for(id in 1:99){
cluster <- rep(id,cluster.size.all[id])
A <- c(rep(1,num.exposed.all[id]),rep(0,num.unexposed.all[id]))
one.cluster <- cbind(cluster,A)
all.clusters <- rbind(all.clusters,one.cluster)
}
all.clusters
# Generate clusters in which larger clusters have more exposed individuals
cluster.size.all <- c()
num.exposed.all <- c()
for(i in 1:99){
cluster.size.all <- c(cluster.size.all,100*i)
num.exposed.all <- c(num.exposed.all,(i/100)*cluster.size.all[i])
}
num.unexposed.all <- cluster.size.all - num.exposed.all
# Construct sample
data <- data.frame(cluster = integer(), A = integer())
for(id in 1:99){
cluster <- rep(id,cluster.size.all[id])
A <- c(rep(1,num.exposed.all[id]),rep(0,num.unexposed.all[id]))
one.cluster <- cbind(cluster,A)
data <- rbind(data,one.cluster)
}
num.exposed.all + num.unexposed.all == cluster.size.all
rep(1,num.exposed.all[id])
rep(0,num.unexposed.all[id])
rep(id,cluster.size.all[id])
one.cluster <- cbind(cluster,A)
data <- rbind(data,one.cluster)
cluster <- rep(id,cluster.size.all[id])
A <- c(rep(1,num.exposed.all[id]),rep(0,num.unexposed.all[id]))
one.cluster <- cbind(cluster,A)
data <- rbind(data,one.cluster)
# Generate clusters in which larger clusters have more exposed individuals
cluster.size.all <- c()
num.exposed.all <- c()
for(i in 1:99){
cluster.size.all <- c(cluster.size.all,100*i)
num.exposed.all <- c(num.exposed.all,(i/100)*cluster.size.all[i])
}
num.unexposed.all <- cluster.size.all - num.exposed.all
# Construct sample
data <- data.frame(cluster = integer(), A = integer())
for(id in 1:99){
cluster <- rep(id,cluster.size.all[id])
A <- c(rep(1,num.exposed.all[id]),rep(0,num.unexposed.all[id]))
one.cluster <- cbind(cluster,A)
data <- rbind(data,one.cluster)
}
# Generate clusters in which larger clusters have more exposed individuals
cluster.size.all <- c()
num.exposed.all <- c()
for(i in 1:99){
cluster.size.all <- c(cluster.size.all,100*i)
num.exposed.all <- c(num.exposed.all,(i/100)*cluster.size.all[i])
}
num.unexposed.all <- cluster.size.all - num.exposed.all
# Construct sample
data <- data.frame(cluster = integer(), A = integer())
for(id in 1:99){
cluster <- rep(id,cluster.size.all[id])
A <- c(rep(1,num.exposed.all[id]),rep(0,num.unexposed.all[id]))
one.cluster <- data.frame(cluster,A)
data <- rbind(data,one.cluster)
}
cluster.size.all
num.exposed.all
num.unexposed.all
# Generate clusters in which larger clusters have more exposed individuals
cluster.size.all <- c()
num.exposed.all <- c()
for(i in 1:99){
cluster.size.all <- c(cluster.size.all,100*i)
num.exposed.all <- c(num.exposed.all,(i/100)*cluster.size.all[i])
}
num.unexposed.all <- cluster.size.all - num.exposed.all
# Construct sample
data <- data.frame(cluster = integer(), A = integer())
for(id in 1:99){
cluster <- rep(id,cluster.size.all[id])
A <- c(rep(1,num.exposed.all[id]),rep(0,num.unexposed.all[id]))
one.cluster <- data.frame(cluster,A)
data <- rbind(data,one.cluster)
}
rep(1,num.exposed.all[id])
one.cluster <- data.frame(cluster,A)
lengt(cluster)
length(cluster)
length(A)
num.exposed.all[id] + num.unexposed.all[id]
A <- c(rep(1,num.exposed.all[id]),rep(0,num.unexposed.all[id]))
length(A)
table(A)
num.exposed.all[id]
length(rep(1,num.exposed.all[id]))
num.exposed.all[id]
table(all.cluster)
length(rep(1,841))
# Generate clusters in which larger clusters have more exposed individuals
cluster.size.all <- c()
num.exposed.all <- c()
for(i in 1:99){
cluster.size.all <- c(cluster.size.all,100*i)
num.exposed.all <- c(num.exposed.all,(i/100)*cluster.size.all[i])
}
num.unexposed.all <- cluster.size.all - num.exposed.all
# Construct sample
data <- data.frame(cluster = integer(), A = integer())
for(id in 1:99){
cluster <- rep(id,cluster.size.all[id])
num.exposed <- num.exposed.all[id]
num.unexposed <- num.unexposed.all[id]
A <- c(rep(1,num.exposed),rep(0,num.unexposed))
one.cluster <- data.frame(cluster,A)
data <- rbind(data,one.cluster)
}
num.exposed
num.unexposed
length(A)
length(A)
length(A)
length(A)
length(A)
length(c(rep(1,num.exposed),rep(0,num.unexposed)))
num.exposed + num.unexposed
length(cluster)
# Generate clusters in which larger clusters have more exposed individuals
cluster.size.all <- c()
num.exposed.all <- c()
for(i in 1:99){
cluster.size.all <- c(cluster.size.all,100*i)
num.exposed.all <- c(num.exposed.all,(i/100)*cluster.size.all[i])
}
num.unexposed.all <- cluster.size.all - num.exposed.all
# Generate clusters in which larger clusters have more exposed individuals
cluster.size.all <- c()
num.exposed.all <- c()
for(i in 1:99){
cluster.size.all <- c(cluster.size.all,100*i)
num.exposed.all <- c(num.exposed.all,(i/100)*cluster.size.all[i])
}
num.unexposed.all <- cluster.size.all - num.exposed.all
# Construct sample
data <- data.frame(cluster = integer(), A = integer())
for(id in 1:99){
cluster.size <- cluster.size.all[id]
print(cluster.size)
num.exposed <- num.exposed.all[id]
print(num.exposed)
num.unexposed <- num.unexposed.all[id]
print(num.unexposed)
print(num.exposed+num.unexposed)
cluster <- rep(id,cluster.size)
A <- c(rep(1,num.exposed),rep(0,num.unexposed))
one.cluster <- data.frame(cluster,A)
data <- rbind(data,one.cluster)
}
